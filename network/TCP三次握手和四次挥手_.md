### 1.三次握手
如下图，A运行的是TCP客户程序，B运行TCP服务端程序。最初两端状态都是CLOSED(关闭)状态。A主动打开连接，B被动打开连接。  

![san](san.jpg)

- B的进程先创建传输控制块TCB,准备接受客户端进程的连接请求。然后服务器进程进入LISTEN(收听)状态，等待客户的连接请求。 

- A的TCP客户进程也先创建传输控制块TCB,然后向B发出连接请求报文，这时报文首部中的同步位SYN=1（TCP中，SYN=1的报文段不能携带数据，但会消耗一个序号）,同时选择一个初始序号seq=x。这时TCP客户进程进入SYN-SENT（同步已发送）状态。  

- B收到连接请求报文后，同意建立连接，向A发送确认。在确认报文中把SYN位和ACK位置于1，确认号是ack=x+1,同时这个报文选择初始序号seq=y。这个报文段不能携带数据，但也消耗序号。发送完确认报文后进程进入SYN-RCVD（同步收到）状态。  

- TCP客户进程A收到B的确认后，再向B发送确认。确认报文ACK置于1，确认号ack=y+1,序号是seq=x+1。ACK报文段可以携带数据，但是不消耗序号，所以下一个报文段序号依然是seq=x+1。这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。  
  
- 当B收到A的确认后，也进入（已建立连接）状态。

_摘录：《计算机网络》第五版 谢希仁_

### 2.TCP的连接释放（四次挥手）
- 如图，数据传输时，A和B都处于ESTABLISHED状态。A的应用进程先向TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文首部的FIN置1，其序号seq=u。这时A进入FIN-WAIT-1(终止等待1)状态，等待B确认（FIN无论是否携带数据都消耗一个序号）。

![四次挥手](img/si.png)

- B在收到A的连接释放报文后发出确认，确认号ack=u+1，序号是v。然后B进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程通知高层应用进程，这时A到B的连接已经释放了，这时的TCP连接处于半封闭状态，A没有数据发送，但B如过向A发送数据，A也能接收，B到A的连接依然存在。

- A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待发出连接释放报文段。

- 如果B已经没有数据再向A发送，则它的应用进程就通知TCP释放连接。发出的释放连接报文段FIN=1。序号为W（上一次发送的报文序号+1）,重复使用上次已用过的确认号ack=u+1。然后B进入LAST-ACK（最后确认）状态。

- A收到B的释放报文后发出确认。确认报文段ACK置1，确认号ack=w+1,序号seq=u+1.然后进入TIME-WAIT（时间等待）状态。此时TCP连接还没有彻底释放。必须经过时间等待计时器设置的2MSL（最长报文寿命MSL，时间为两分钟）时间后，A才能进入CLOSED状态。最后A会撤销掉相应的控制块TCB,彻底结束本次TCP连接。

__转载：谢希仁 《计算机网络》（第五版）__  
__图片来自Google__
   
